<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Jeddah Route Finder (Fix Coord Flip)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 9999;
      background: white; padding: 10px; border-radius: 6px;
    }
  </style>
</head>
<body>
<div id="controls">
  <input type="file" id="fileInput" multiple><br><br>
  <button id="startBtn">Select Start</button>
  <button id="endBtn">Select End</button>
  <button id="routeBtn">Find Route</button>
  <button id="debugBtn">Toggle Graph Debug</button>
</div>
<div id="map"></div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const SNAP_RADIUS = 0.0005;
let map = L.map('map').setView([21.65, 39.2], 11);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

let graph = {}, startPoint = null, endPoint = null;
let startMarker = null, endMarker = null;
let snapStartMarker = null, snapEndMarker = null;
let allCoords = new Set();
let debugLayer = L.layerGroup().addTo(map);

function toId(coord) {
  return coord[0].toFixed(6) + "," + coord[1].toFixed(6);
}

function distance(a, b) {
  const dx = a[0] - b[0], dy = a[1] - b[1];
  return Math.sqrt(dx*dx + dy*dy);
}

function findNearby(coord) {
  let min = Infinity, best = null;
  for (let id of allCoords) {
    let pt = id.split(',').map(Number);
    let d = distance(coord, pt);
    if (d < min && d < SNAP_RADIUS) {
      min = d;
      best = pt;
    }
  }
  return best;
}

function addToGraph(a, b) {
  let aid = toId(a), bid = toId(b);
  allCoords.add(aid);
  allCoords.add(bid);
  graph[aid] = graph[aid] || [];
  graph[aid].push({ coord: b, id: bid });
  graph[bid] = graph[bid] || [];
  graph[bid].push({ coord: a, id: aid });
}

function drawGraph() {
  debugLayer.clearLayers();
  for (let aid in graph) {
    let a = aid.split(',').map(Number);
    L.circleMarker(a, { radius: 2, color: '#999' }).addTo(debugLayer);
    for (let { coord: b } of graph[aid]) {
      L.polyline([a, b], { color: '#ccc', weight: 1 }).addTo(debugLayer);
    }
  }
}

function handleGeoJSON(data) {
  L.geoJSON(data, {
    onEachFeature: function (feature) {
      let coords = feature.geometry.coordinates;
      if (feature.geometry.type === "LineString") {
        for (let i = 0; i < coords.length - 1; i++) {
          let a = [coords[i][1], coords[i][0]];   // flip [lon, lat] â†’ [lat, lon]
          let b = [coords[i+1][1], coords[i+1][0]];
          let snapA = findNearby(a) || a;
          let snapB = findNearby(b) || b;
          addToGraph(snapA, snapB);
        }
      }
    }
  }).addTo(map);
}

function getClosestNode(latlng) {
  let min = Infinity, closest = null;
  for (let id of allCoords) {
    let coord = id.split(',').map(Number);
    let d = distance([latlng.lat, latlng.lng], coord);
    if (d < min) {
      min = d;
      closest = id;
    }
  }
  return closest;
}

function dijkstra(start, end) {
  let dist = {}, prev = {}, Q = new Set(Object.keys(graph));
  for (let v of Q) dist[v] = Infinity;
  dist[start] = 0;
  while (Q.size > 0) {
    let u = [...Q].reduce((a, b) => dist[a] < dist[b] ? a : b);
    Q.delete(u);
    if (u === end) break;
    for (let { id: v, coord } of graph[u]) {
      let alt = dist[u] + distance(u.split(',').map(Number), coord);
      if (alt < dist[v]) {
        dist[v] = alt;
        prev[v] = u;
      }
    }
  }
  let path = [], u = end;
  while (u) {
    path.unshift(u);
    u = prev[u];
  }
  return path.map(p => p.split(',').map(Number));
}

document.getElementById('fileInput').addEventListener('change', function(e) {
  for (let file of e.target.files) {
    let reader = new FileReader();
    reader.onload = function(e) {
      let geo = JSON.parse(e.target.result);
      handleGeoJSON(geo);
    };
    reader.readAsText(file);
  }
});

document.getElementById('startBtn').onclick = function() {
  map.once('mousemove', function(preview) {
    const temp = L.circleMarker(preview.latlng, { radius: 5, color: 'green' }).addTo(map);
    const move = e => temp.setLatLng(e.latlng);
    const click = e => {
      map.off('mousemove', move);
      map.off('click', click);
      map.removeLayer(temp);
      startPoint = e.latlng;
      if (startMarker) map.removeLayer(startMarker);
      startMarker = L.marker(e.latlng).addTo(map).bindPopup("Start").openPopup();
    };
    map.on('mousemove', move);
    map.on('click', click);
  });
};

document.getElementById('endBtn').onclick = function() {
  map.once('mousemove', function(preview) {
    const temp = L.circleMarker(preview.latlng, { radius: 5, color: 'red' }).addTo(map);
    const move = e => temp.setLatLng(e.latlng);
    const click = e => {
      map.off('mousemove', move);
      map.off('click', click);
      map.removeLayer(temp);
      endPoint = e.latlng;
      if (endMarker) map.removeLayer(endMarker);
      endMarker = L.marker(e.latlng).addTo(map).bindPopup("End").openPopup();
    };
    map.on('mousemove', move);
    map.on('click', click);
  });
};

document.getElementById('debugBtn').onclick = function() {
  if (map.hasLayer(debugLayer)) {
    map.removeLayer(debugLayer);
  } else {
    drawGraph();
    map.addLayer(debugLayer);
  }
};

document.getElementById('routeBtn').onclick = function() {
  if (!startPoint || !endPoint) return alert("Select start and end points first.");
  let startId = getClosestNode(startPoint);
  let endId = getClosestNode(endPoint);
  console.log("Start snapped to:", startId);
  console.log("End snapped to:", endId);
  if (snapStartMarker) map.removeLayer(snapStartMarker);
  if (snapEndMarker) map.removeLayer(snapEndMarker);
  snapStartMarker = L.circleMarker(startId.split(',').map(Number), { color: 'green', radius: 6 }).addTo(map).bindPopup("Snapped Start").openPopup();
  snapEndMarker = L.circleMarker(endId.split(',').map(Number), { color: 'red', radius: 6 }).addTo(map).bindPopup("Snapped End").openPopup();
  if (!graph[startId] || !graph[endId]) return alert("Start or End point not near any road segment.");
  if (startId === endId) {
    alert("Start and End are the same location.");
    return L.circleMarker(startId.split(',').map(Number), { color: 'blue', radius: 4 }).addTo(map).bindPopup("Same Point").openPopup();
  }
  let path = dijkstra(startId, endId);
  console.log("Path length:", path.length);
  if (path.length < 2) return alert("No path found.");
  L.polyline(path, { color: 'blue' }).addTo(map);
};
</script>
</body>
</html>
