<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Jeddah Route Finder (Persistent Tiles)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 9999;
      background: white; padding: 10px; border-radius: 6px;
    }
  </style>
</head>
<body>
<div id="controls">
  <input type="file" id="fileInput" multiple><br><br>
  <button id="startBtn">Select Start</button>
  <button id="endBtn">Select End</button>
  <button id="routeBtn">Find Route</button>
  <button id="debugBtn">Toggle Graph Debug</button>
  <button id="clearBtn">Clear Saved Tiles</button>
</div>
<div id="map"></div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const SNAP_RADIUS = 0.0005;
let map = L.map('map').setView([21.65, 39.2], 11);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

let graph = {}, startPoint = null, endPoint = null;
let startMarker = null, endMarker = null;
let snapStartMarker = null, snapEndMarker = null;
let allCoords = new Set();
let debugLayer = L.layerGroup().addTo(map);

function toId(coord) {
  return coord[0].toFixed(6) + "," + coord[1].toFixed(6);
}

function distance(a, b) {
  const dx = a[0] - b[0], dy = a[1] - b[1];
  return Math.sqrt(dx * dx + dy * dy);
}

function findNearby(coord) {
  let min = Infinity, best = null;
  for (let id of allCoords) {
    let pt = id.split(',').map(Number);
    let d = distance(coord, pt);
    if (d < min && d < SNAP_RADIUS) {
      min = d;
      best = pt;
    }
  }
  return best;
}

function addToGraph(a, b) {
  let aid = toId(a), bid = toId(b);
  allCoords.add(aid);
  allCoords.add(bid);
  graph[aid] = graph[aid] || [];
  graph[aid].push({ coord: b, id: bid });
  graph[bid] = graph[bid] || [];
  graph[bid].push({ coord: a, id: aid });
}

function drawGraph() {
  debugLayer.clearLayers();
  for (let aid in graph) {
    let a = aid.split(',').map(Number);
    L.circleMarker(a, { radius: 2, color: '#999' }).addTo(debugLayer);
    for (let { coord: b } of graph[aid]) {
      L.polyline([a, b], { color: '#ccc', weight: 1 }).addTo(debugLayer);
    }
  }
}

function handleGeoJSON(data) {
  L.geoJSON(data, {
    onEachFeature: function (feature) {
      let coords = feature.geometry.coordinates;
      if (feature.geometry.type === "LineString") {
        let points = coords.map(c => [c[1], c[0]]);
        for (let i = 0; i < points.length - 1; i++) {
          let a = findNearby(points[i]) || points[i];
          let b = findNearby(points[i + 1]) || points[i + 1];
          addToGraph(a, b);
        }
      }
    }
  }).addTo(map);
}

function getClosestNode(latlng) {
  let min = Infinity, closest = null;
  for (let id of allCoords) {
    let coord = id.split(',').map(Number);
    let d = distance([latlng.lat, latlng.lng], coord);
    if (d < min) {
      min = d;
      closest = id;
    }
  }
  return closest;
}

function dijkstra(start, end) {
  let dist = {}, prev = {}, Q = new Set(Object.keys(graph));
  for (let v of Q) dist[v] = Infinity;
  dist[start] = 0;
  while (Q.size > 0) {
    let u = [...Q].reduce((a, b) => dist[a] < dist[b] ? a : b);
    Q.delete(u);
    if (u === end) break;
    for (let neighbor of graph[u]) {
      let v = neighbor.id;
      let alt = dist[u] + distance(u.split(',').map(Number), neighbor.coord);
      if (alt < dist[v]) {
        dist[v] = alt;
        prev[v] = u;
      }
    }
  }
  let route = [], u = end;
  while (u && prev[u]) {
    route.unshift(u);
    u = prev[u];
  }
  route.unshift(start);
  return route.map(p => p.split(',').map(Number));
}

function loadFromStorage() {
  const files = Object.keys(localStorage).filter(k => k.startsWith('geojson:'));
  files.forEach(key => {
    try {
      const data = JSON.parse(localStorage.getItem(key));
      handleGeoJSON(data);
    } catch (e) {
      console.error("Failed to load", key);
    }
  });
}

document.getElementById('fileInput').addEventListener('change', function (e) {
  for (let file of e.target.files) {
    let reader = new FileReader();
    reader.onload = function (e) {
      let geo = JSON.parse(e.target.result);
      localStorage.setItem("geojson:" + file.name, JSON.stringify(geo));
      handleGeoJSON(geo);
    };
    reader.readAsText(file);
  }
});

document.getElementById('clearBtn').onclick = function () {
  Object.keys(localStorage).forEach(key => {
    if (key.startsWith("geojson:")) localStorage.removeItem(key);
  });
  alert("Saved tiles cleared. Please refresh.");
};

document.getElementById('startBtn').onclick = function () {
  map.once('click', function (e) {
    startPoint = e.latlng;
    if (startMarker) map.removeLayer(startMarker);
    startMarker = L.marker(e.latlng).addTo(map).bindPopup("Start").openPopup();
  });
};

document.getElementById('endBtn').onclick = function () {
  map.once('click', function (e) {
    endPoint = e.latlng;
    if (endMarker) map.removeLayer(endMarker);
    endMarker = L.marker(e.latlng).addTo(map).bindPopup("End").openPopup();
  });
};

document.getElementById('debugBtn').onclick = function () {
  if (map.hasLayer(debugLayer)) {
    map.removeLayer(debugLayer);
  } else {
    drawGraph();
    map.addLayer(debugLayer);
  }
};

document.getElementById('routeBtn').onclick = function () {
  if (!startPoint || !endPoint) return alert("Select start and end points first.");
  let startId = getClosestNode(startPoint);
  let endId = getClosestNode(endPoint);
  console.log("Start snapped to:", startId);
  console.log("End snapped to:", endId);
  if (snapStartMarker) map.removeLayer(snapStartMarker);
  if (snapEndMarker) map.removeLayer(snapEndMarker);
  snapStartMarker = L.circleMarker(startId.split(',').map(Number), { color: 'green', radius: 6 }).addTo(map).bindPopup("Snapped Start").openPopup();
  snapEndMarker = L.circleMarker(endId.split(',').map(Number), { color: 'red', radius: 6 }).addTo(map).bindPopup("Snapped End").openPopup();
  if (!graph[startId] || !graph[endId]) return alert("Start or End point not near any road segment.");
  if (startId === endId) {
    alert("Start and End are the same location.");
    return L.circleMarker(startId.split(',').map(Number), { color: 'blue', radius: 4 }).addTo(map).bindPopup("Same Point").openPopup();
  }
  let route = dijkstra(startId, endId);
  console.log("Path length:", route.length);
  if (route.length < 2) return alert("No path found.");
  L.polyline(route, { color: 'blue' }).addTo(map);
};

// Load from cache on startup
loadFromStorage();
</script>
</body>
</html>
