<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Jeddah Route Finder (High Precision)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 9999;
      background: white; padding: 10px; border-radius: 6px;
    }
    #steps {
      position: absolute; bottom: 10px; left: 10px; z-index: 9999;
      background: white; padding: 10px; border-radius: 6px;
      max-height: 30%; overflow-y: auto;
      font-size: 14px;
    }
  </style>
</head>
<body>
<div id="controls">
  <input type="file" id="fileInput" multiple><br><br>
  <button id="startBtn">Select Start</button>
  <button id="endBtn">Select End</button>
  <button id="waypointBtn">Add Waypoint</button>
  <button id="routeBtn">Find Route</button>
  <button id="debugBtn">Toggle Graph Debug</button>
  <button id="blockModeBtn">ðŸ”§ Toggle Block Mode</button>
</div>
<div id="steps"><strong>Steps:</strong><br><ul id="stepList"></ul></div>
<div id="map"></div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const SNAP_RADIUS = 0.0005;
let map = L.map('map').setView([21.65, 39.2], 11);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

let graph = {}, startPoint = null, endPoint = null;
let waypoints = [];
let blockedEdges = new Set();
let blockMode = false;
let selectingMode = null; // "start" | "end" | "waypoint"
let allCoords = new Set();
let debugLayer = L.layerGroup().addTo(map);

function toId(coord) {
  return coord[0].toFixed(6) + "," + coord[1].toFixed(6);
}

function distance(a, b) {
  const dx = a[0] - b[0], dy = a[1] - b[1];
  return Math.sqrt(dx * dx + dy * dy);
}

function findNearby(coord) {
  let min = Infinity, best = null;
  for (let id of allCoords) {
    let pt = id.split(',').map(Number);
    let d = distance(coord, pt);
    if (d < min && d < SNAP_RADIUS) {
      min = d;
      best = pt;
    }
  }
  return best;
}

function addToGraph(a, b) {
  let aid = toId(a), bid = toId(b);
  allCoords.add(aid);
  allCoords.add(bid);
  graph[aid] = graph[aid] || [];
  graph[aid].push({ coord: b, id: bid });
  graph[bid] = graph[bid] || [];
  graph[bid].push({ coord: a, id: aid });
}

function drawGraph() {
  debugLayer.clearLayers();
  for (let aid in graph) {
    let a = aid.split(',').map(Number);
    for (let { coord: b, id: bid } of graph[aid]) {
      let edgeId = aid + "_" + bid;
      let blocked = blockedEdges.has(edgeId) || blockedEdges.has(bid + "_" + aid);
      let poly = L.polyline([a, b], {
        color: blocked ? 'gray' : '#ccc',
        weight: 2,
        dashArray: blocked ? '5, 5' : null
      });
      poly.on('click', () => {
        if (!blockMode) return;
        if (blockedEdges.has(edgeId)) blockedEdges.delete(edgeId);
        else blockedEdges.add(edgeId);
        drawGraph();
      });
      poly.addTo(debugLayer);
    }
  }
}

function handleGeoJSON(data) {
  L.geoJSON(data, {
    onEachFeature: function (feature) {
      let coords = feature.geometry.coordinates;
      if (feature.geometry.type === "LineString") {
        let points = coords.map(c => [c[1], c[0]]);
        for (let i = 0; i < points.length - 1; i++) {
          let a = findNearby(points[i]) || points[i];
          let b = findNearby(points[i + 1]) || points[i + 1];
          addToGraph(a, b);
        }
      }
    }
  }).addTo(map);
}

function getClosestNode(latlng) {
  let min = Infinity, closest = null;
  for (let id of allCoords) {
    let coord = id.split(',').map(Number);
    let d = distance([latlng.lat, latlng.lng], coord);
    if (d < min) {
      min = d;
      closest = id;
    }
  }
  return closest;
}

function aStar(start, goal) {
  let openSet = new Set([start]);
  let cameFrom = {}, gScore = {}, fScore = {};
  for (let v in graph) gScore[v] = fScore[v] = Infinity;
  gScore[start] = 0;
  fScore[start] = distance(start.split(',').map(Number), goal.split(',').map(Number));

  while (openSet.size > 0) {
    let current = [...openSet].reduce((a, b) => fScore[a] < fScore[b] ? a : b);
    if (current === goal) {
      let path = [], temp = current;
      while (temp) {
        path.unshift(temp);
        temp = cameFrom[temp];
      }
      return path.map(p => p.split(',').map(Number));
    }
    openSet.delete(current);
    for (let neighbor of graph[current]) {
      let edgeId = current + "_" + neighbor.id;
      if (blockedEdges.has(edgeId) || blockedEdges.has(neighbor.id + "_" + current)) continue;
      let tentative_g = gScore[current] + distance(current.split(',').map(Number), neighbor.coord);
      if (tentative_g < gScore[neighbor.id]) {
        cameFrom[neighbor.id] = current;
        gScore[neighbor.id] = tentative_g;
        fScore[neighbor.id] = tentative_g + distance(neighbor.coord, goal.split(',').map(Number));
        openSet.add(neighbor.id);
      }
    }
  }
  return [];
}

function calculateRoute(points) {
  if (points.length < 2) return;
  let steps = [], fullPath = [];
  for (let i = 0; i < points.length - 1; i++) {
    let seg = aStar(points[i], points[i + 1]);
    if (seg.length < 2) return alert("No path found between segment " + (i + 1));
    fullPath.push(...(i > 0 ? seg.slice(1) : seg));
    let dist = 0;
    for (let j = 0; j < seg.length - 1; j++) dist += distance(seg[j], seg[j + 1]);
    steps.push(`Follow segment ${i + 1} for ${(dist * 111).toFixed(3)} km`);
  }
  L.polyline(fullPath, { color: 'orange', weight: 4 }).addTo(map);
  document.getElementById('stepList').innerHTML = steps.map(s => `<li>${s}</li>`).join('');
}

map.on('click', function (e) {
  let id = getClosestNode(e.latlng);
  if (!id) return alert("No nearby road node found.");
  if (blockMode) return; // disable placing points in block mode
  if (selectingMode === "start") {
    waypoints = [id];
    L.circleMarker(id.split(',').map(Number), { color: 'green', radius: 6 }).addTo(map).bindPopup('Start').openPopup();
  } else if (selectingMode === "end") {
    waypoints.push(id);
    L.circleMarker(id.split(',').map(Number), { color: 'red', radius: 6 }).addTo(map).bindPopup('End').openPopup();
    calculateRoute(waypoints);
  } else if (selectingMode === "waypoint") {
    waypoints.splice(waypoints.length - 1, 0, id);
    L.circleMarker(id.split(',').map(Number), { color: 'purple', radius: 6 }).addTo(map).bindPopup(`WP${waypoints.length - 2}`).openPopup();
    calculateRoute(waypoints);
  }
});

// Event Listeners

document.getElementById('fileInput').addEventListener('change', function (e) {
  for (let file of e.target.files) {
    let reader = new FileReader();
    reader.onload = function (e) {
      let geo = JSON.parse(e.target.result);
      handleGeoJSON(geo);
    };
    reader.readAsText(file);
  }
});

document.getElementById('startBtn').onclick = () => { selectingMode = "start"; alert("Click on map to set START point."); };
document.getElementById('endBtn').onclick = () => { selectingMode = "end"; alert("Click on map to set END point."); };
document.getElementById('waypointBtn').onclick = () => { selectingMode = "waypoint"; alert("Click on map to add WAYPOINT."); };

document.getElementById('debugBtn').onclick = () => {
  if (map.hasLayer(debugLayer)) map.removeLayer(debugLayer);
  else { drawGraph(); map.addLayer(debugLayer); }
};

document.getElementById('blockModeBtn').onclick = function () {
  blockMode = !blockMode;
  selectingMode = null;
  alert("Block Mode: " + (blockMode ? "ON" : "OFF"));
  drawGraph();
};
</script>
</body>
</html>
