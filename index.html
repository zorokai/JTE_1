<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Jeddah Route Finder (High Precision)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 9999;
      background: white; padding: 10px; border-radius: 6px;
    }
    #steps {
      position: absolute; bottom: 10px; left: 10px; z-index: 9999;
      background: white; padding: 10px; border-radius: 6px;
      max-height: 200px; overflow-y: auto; font-size: 14px;
    }
  </style>
</head>
<body>
<div id="controls">
  <input type="file" id="fileInput" multiple><br><br>
  <button id="startBtn">Add Start Point</button>
  <button id="waypointBtn">Add Waypoint</button>
  <button id="endBtn">Add End Point</button>
  <button id="routeBtn">Find Route</button>
  <button id="resetBtn">Reset Route</button>
  <button id="blockBtn">ðŸ”§ Toggle Block Mode</button>
  <button id="debugBtn">Toggle Graph Debug</button>
</div>
<div id="steps"><strong>Steps:</strong><ul id="instructions"></ul></div>
<div id="map"></div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const SNAP_RADIUS = 0.0005;
let map = L.map('map').setView([21.65, 39.2], 11);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

let graph = {}, allCoords = new Set();
let startPoint = null, endPoint = null;
let startMarker = null, endMarker = null, snapStartMarker = null, snapEndMarker = null;
let debugLayer = L.layerGroup().addTo(map);
let blockMode = false, blockedEdges = new Set(), routeLayer = null;
let waypoints = [], waypointMarkers = [], roadPolylines = [];

function toId(c) { return c[0].toFixed(6)+","+c[1].toFixed(6); }
function distance(a, b) { const dx=a[0]-b[0], dy=a[1]-b[1]; return Math.sqrt(dx*dx + dy*dy); }
function findNearby(c) {
  let min=Infinity, best=null;
  for (let id of allCoords) {
    let pt = id.split(',').map(Number);
    let d = distance(c, pt);
    if (d < min && d < SNAP_RADIUS) { min = d; best = pt; }
  }
  return best;
}
function addToGraph(a, b) {
  const aid = toId(a), bid = toId(b);
  allCoords.add(aid); allCoords.add(bid);
  graph[aid] = graph[aid] || [];
  graph[aid].push({coord: b, id: bid});
  graph[bid] = graph[bid] || [];
  graph[bid].push({coord: a, id: aid});
}
function drawGraph() {
  debugLayer.clearLayers();
  for (let aid in graph) {
    let a = aid.split(',').map(Number);
    L.circleMarker(a, { radius: 2, color: '#999' }).addTo(debugLayer);
    for (let { coord: b } of graph[aid]) {
      L.polyline([a, b], { color: '#ccc', weight: 1 }).addTo(debugLayer);
    }
  }
}
function handleGeoJSON(data) {
  L.geoJSON(data, {
    onEachFeature: function (feature) {
      let coords = feature.geometry.coordinates;
      if (feature.geometry.type === "LineString") {
        let points = coords.map(c => [c[1], c[0]]);
        for (let i = 0; i < points.length - 1; i++) {
          let a = findNearby(points[i]) || points[i];
          let b = findNearby(points[i + 1]) || points[i + 1];
          addToGraph(a, b);
          const poly = L.polyline([a, b], { color: '#444', weight: 3 }).addTo(map);
          roadPolylines.push(poly);
          poly.on('click', function () {
            if (!blockMode) return;
            const id1 = toId(a), id2 = toId(b);
            blockedEdges.add(`${id1}|${id2}`);
            blockedEdges.add(`${id2}|${id1}`);
            poly.setStyle({ color: 'black', dashArray: '5,5' });
          });
        }
      }
    }
  });
}
function getClosestNode(latlng) {
  let min = Infinity, closest = null;
  for (let id of allCoords) {
    let coord = id.split(',').map(Number);
    let d = distance([latlng.lat, latlng.lng], coord);
    if (d < min) { min = d; closest = id; }
  }
  return closest;
}
function dijkstra(start, end) {
  let dist = {}, prev = {}, Q = new Set(Object.keys(graph));
  for (let v of Q) dist[v] = Infinity;
  dist[start] = 0;
  while (Q.size > 0) {
    let u = [...Q].reduce((a, b) => dist[a] < dist[b] ? a : b);
    Q.delete(u);
    if (u === end) break;
    for (let neighbor of graph[u]) {
      let v = neighbor.id;
      if (blockedEdges.has(`${u}|${v}`)) continue;
      let alt = dist[u] + distance(u.split(',').map(Number), neighbor.coord);
      if (alt < dist[v]) {
        dist[v] = alt;
        prev[v] = u;
      }
    }
  }
  let route = [], u = end;
  while (u && prev[u]) {
    route.unshift(u);
    u = prev[u];
  }
  route.unshift(start);
  return route.map(p => p.split(',').map(Number));
}
function renderSteps(route) {
  let ul = document.getElementById('instructions');
  ul.innerHTML = '';
  function getDirection(a, b) {
    let angle = Math.atan2(b[1] - a[1], b[0] - a[0]) * (180 / Math.PI);
    if (angle < 0) angle += 360;
    if (angle >= 337.5 || angle < 22.5) return 'East';
    if (angle < 67.5) return 'Northeast';
    if (angle < 112.5) return 'North';
    if (angle < 157.5) return 'Northwest';
    if (angle < 202.5) return 'West';
    if (angle < 247.5) return 'Southwest';
    if (angle < 292.5) return 'South';
    return 'Southeast';
  }
  for (let i = 0; i < route.length - 1; i++) {
    let d = distance(route[i], route[i+1]) * 111.32;
    let dir = getDirection(route[i], route[i+1]);
    let li = document.createElement('li');
    li.innerText = `Go ${dir} for ${d.toFixed(3)} km`;
    ul.appendChild(li);
  }
}
function calculateRoute() {
  if (waypoints.length < 2) return alert("Set at least start and end point");
  if (routeLayer) {
    map.removeLayer(routeLayer);
    routeLayer = null;
  }
  let coords = waypoints.map(p => getClosestNode(p));
  let fullRoute = [];
  for (let i = 0; i < coords.length - 1; i++) {
    let segment = dijkstra(coords[i], coords[i+1]);
    if (segment.length < 2) return alert("No path between some points");
    fullRoute.push(...(i === 0 ? segment : segment.slice(1)));
  }
  routeLayer = L.polyline(fullRoute, { color: 'orange' }).addTo(map);
  renderSteps(fullRoute);
}

startBtn.onclick = () => {
  map.once('click', e => {
    if (startMarker) map.removeLayer(startMarker);
    startPoint = e.latlng;
    startMarker = L.marker(e.latlng).addTo(map).bindPopup("Start").openPopup();
    waypoints[0] = e.latlng;
  });
};

waypointBtn.onclick = () => {
  map.once('click', e => {
    const marker = L.marker(e.latlng, { color: 'purple' }).addTo(map).bindPopup("Waypoint").openPopup();
    waypointMarkers.push(marker);
    waypoints.push(e.latlng);
    calculateRoute();
  });
};

endBtn.onclick = () => {
  map.once('click', e => {
    if (endMarker) map.removeLayer(endMarker);
    endPoint = e.latlng;
    endMarker = L.marker(e.latlng).addTo(map).bindPopup("End").openPopup();
    waypoints[waypoints.length] = e.latlng;
    calculateRoute();
  });
};

resetBtn.onclick = () => {
  if (routeLayer) map.removeLayer(routeLayer);
  if (startMarker) map.removeLayer(startMarker);
  if (endMarker) map.removeLayer(endMarker);
  if (snapStartMarker) map.removeLayer(snapStartMarker);
  if (snapEndMarker) map.removeLayer(snapEndMarker);
  for (let m of waypointMarkers) map.removeLayer(m);
  waypointMarkers = [];
  waypoints = [];
  startPoint = null;
  endPoint = null;
  document.getElementById('instructions').innerHTML = '';
};

fileInput.addEventListener('change', function (e) {
  for (let file of e.target.files) {
    let reader = new FileReader();
    reader.onload = function (e) {
      let geo = JSON.parse(e.target.result);
      handleGeoJSON(geo);
    };
    reader.readAsText(file);
  }
});

debugBtn.onclick = () => {
  if (map.hasLayer(debugLayer)) map.removeLayer(debugLayer);
  else drawGraph();
};

blockBtn.onclick = () => {
  blockMode = !blockMode;
  alert("Block mode is now " + (blockMode ? "ON" : "OFF"));
};

routeBtn.onclick = () => {
  calculateRoute();
};
</script>
</body>
</html>
